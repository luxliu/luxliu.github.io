<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://luxliu.github.io</id>
    <title>Lux&apos;s Blog</title>
    <updated>2020-06-07T10:45:32.620Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://luxliu.github.io"/>
    <link rel="self" href="https://luxliu.github.io/atom.xml"/>
    <subtitle>Action as a normal</subtitle>
    <logo>https://luxliu.github.io/images/avatar.png</logo>
    <icon>https://luxliu.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Lux&apos;s Blog</rights>
    <entry>
        <title type="html"><![CDATA[How to improve performance in webpack]]></title>
        <id>https://luxliu.github.io/post/webpack-performance/</id>
        <link href="https://luxliu.github.io/post/webpack-performance/">
        </link>
        <updated>2020-05-27T10:51:27.000Z</updated>
        <content type="html"><![CDATA[<p>As the front-end side is becoming bigger and more complex, sometimes we have to face to the issue of performance. Briefly, we hope the users will experience our web app as faster as possible. This is about to minimize the request files size and optimize the request order. Let's have a look at how could we do this in webpack.</p>
<h4 id="1-tree-shaking">1. Tree Shaking</h4>
<p>As the naming, tree shaking will shake the useless modules even it's claimed in some other files. This will decrease bundle size.</p>
<p>Let's say I have two functions in <code>math.js</code> file:</p>
<pre><code class="language-javascript">export const add = (a, b) =&gt; {
	console.log( a + b );
}

export const minus = (a, b) =&gt; {
	console.log( a - b );
}
</code></pre>
<p>And I only import the <code>add</code> function like this:</p>
<pre><code class="language-javascript">import { add } from './math.js';
add(1, 2);
</code></pre>
<blockquote>
<p>Note: webpack tree shaking only supports the es6 module <code>import</code>, but doesn't support commonJS <code>require</code>, as the es6 <code>import</code> underlying  implementation is static but <code>requires</code> is  dynamic.</p>
</blockquote>
<p>If I have no tree shaking feature here, the bundle will also include the <code>minus</code> function code, which is useless and raise the bundle size.</p>
<p>How do we config tree shaking in webpack?</p>
<h5 id="on-development-mode">On development mode:</h5>
<p>If you need to config for dev mode, make sure you add <code>usedExports</code> within <code>optimization</code> property in your <code>webpack.config.js</code> file like this:</p>
<pre><code class="language-js">optimization: {
    usedExports: true
}
</code></pre>
<p>And, in <code>package.json</code> you should add one line just for future convenience:</p>
<pre><code class="language-json">&quot;sideEffect&quot;: []
</code></pre>
<blockquote>
<p>With this <code>sideEffect</code>, you can add whatever you will let webpack ignores when tree shaking. E.g. you need to <code>import '@babel/polly-fill'</code> in your entry file to do polly-fill job. As you don't use anything of this polly-fill module here, webpack will shake the whole babel/polly-fill module which is not you expect. In this case, you can add this module into the <code>sideEffect</code> array: <code>&quot;sideEffect&quot;: [&quot;@babel/polly-fill&quot;]</code>. Another common example is for <code>import './style.css'</code> and <code>&quot;sideEffect&quot;: [&quot;*.css&quot;]</code>.</p>
</blockquote>
<p><strong>However</strong>, if you run webpack to bundle, you will find the output file still includes the useless <code>minus</code> function but one extra comment before it to tell you <strong>&quot;exports provided: add, minus&quot;</strong> and <strong>&quot;exports used: add&quot;</strong>. The reason is that webpack considers remove these tree shaking modules might cause error when you use source map. So <strong>in development mode</strong>, webpack won't really remove the tree shaking modules code.</p>
<h5 id="on-production-mode">On production mode:</h5>
<p>Nothing need you to do! Webpack will do it for you by default. Just don't forget to add <code>&quot;sideEffect&quot;: []</code> in your <code>package.json</code> file and add something you prevent from tree shaking.</p>
<h4 id="2-code-splitting-and-lazy-loading">2. Code splitting and lazy loading</h4>
<p>I think almost most front-end developers used some utility library like <code>lodash</code>, <code>jquery</code> or <code>ramda</code>. The thing is when a file imports these libraries and use webpack to do the bundling job, the whole bundle size would be pretty big as all these 3rd party libraries are also included in the bundle file. This is not we want!</p>
<p>Let's say you are using <code>lodash</code> in <code>index.js</code> , and you can create another file called <code>lodash.js</code> to do this:</p>
<pre><code class="language-js">import _ from 'lodash';
window._ = _;
</code></pre>
<p>And add it as an extra entry file like this:</p>
<pre><code class="language-js">entry: {
    lodash: './src/lodash.js',
    main: './src/index.js'
}
</code></pre>
<p>With this solution, the bundled <code>index.html</code> will import <code>lodash.js</code> as another <code>&lt;script&gt;</code> file. The benefit is that we split business logic code and vendor code in two different files. When the user reload new code, the <code>lodash.js</code> already cached in browser, and this will speed up user experience.</p>
<blockquote>
<p>Don't forget to use <strong>[contentHash]</strong> as part of your output files naming, especially in production environment, to prevent caching of browser when code content already changed.</p>
</blockquote>
<blockquote>
<p>This concept is code splitting and doesn't matter with webpack. With webpack we can do it easily and simply.</p>
</blockquote>
<p>Just do this in webpack.config.js` file:</p>
<pre><code class="language-js">optimization: {
    splitChunks: {
        chunks: 'all'
    }
}
</code></pre>
<p>Then you will find webpack does the code splitting for you: you will get one extra bundle file: <code>vendors~main.js</code> which includes the imported libraries.</p>
<blockquote>
<p>For more configurations of splitChunks plugin of webpack, you can read its <a href="https://webpack.js.org/plugins/split-chunks-plugin/#root">official documents</a></p>
</blockquote>
<p>Actually, lazy loading can't leave code splitting. Image following code:</p>
<pre><code class="language-js">const getComponent = () =&gt; {
  return import('lodash').then(({ default: _ }) =&gt; {
    const element = document.createElement('div');
    element.innerHTML = _.join(['Lux', 'Liu'], '-');
    return element;
  });
};

document.addEventListener('click', () =&gt; {
  getComponent().then((element) =&gt; {
    document.body.appendChild(element);
  });
});
</code></pre>
<p>And use webpack to bundle project, you should find <code>lodash</code> is bundled in <code>vendors~*.js</code> and the top code is bundled in <code>main.js</code>. Inspect bundled landing page <code>index.html</code> in your browser and open network, you will find only <code>index.html</code> and <code>main.js</code> are requested when you load <code>index.html</code>. Once you click the page, you will see &quot;Lux-Liu&quot; on your page and the <code>vendors~*.js</code> is just requested after you click the page. This is lazy loading and obviously, it will speed up the UX.</p>
<blockquote>
<p>Don't forget to use polly-fill or <a href="https://babeljs.io/docs/en/babel-plugin-syntax-dynamic-import">@babel/plug-syntax-dynamic-import</a> plugin for this experimental syntax.</p>
</blockquote>
<p>Do you remember we have a configuration for code splitting?</p>
<pre><code class="language-js">optimization: {
    splitChunks: {
        chunks: 'all'
    }
}
</code></pre>
<p>If you have no this configuration, webpack will still do code splitting for you, <strong>but only the dynamic import</strong>.</p>
<p>Have a look at the <a href="https://babeljs.io/docs/en/babel-plugin-syntax-dynamic-import">default config</a> of splitChunk plugin:</p>
<pre><code class="language-js">module.exports = {
  //...
  optimization: {
    splitChunks: {
      chunks: 'async',
      minSize: 30000,
      minRemainingSize: 0,
      maxSize: 0,
      minChunks: 1,
      maxAsyncRequests: 6,
      maxInitialRequests: 4,
      automaticNameDelimiter: '~',
      cacheGroups: {
        defaultVendors: {
          test: /[\\/]node_modules[\\/]/,
          priority: -10
        },
        default: {
          minChunks: 2,
          priority: -20,
          reuseExistingChunk: true
        }
      }
    }
  }
};
</code></pre>
<p>By default, the <code>chunks</code> has a <code>async</code> value, which indicates <strong>webpack encourage us to use this lazy loading/dynamic import</strong>.</p>
<h4 id="3-bundle-analyse-preloading-and-prefetching">3. Bundle analyse, preloading and prefetching</h4>
<p>In the real practice, we usually use <a href="https://github.com/webpack/analyse">webpack analyse</a> to do the bundle analysis job.</p>
<p>The process is pretty straight forward and simple:</p>
<ul>
<li>Run <code>webpack --profile --json &gt; stats.json</code> , which also can be combined in your build script, like <code>&quot;dev-build&quot;: &quot;webpack --profile --json &gt; stats.json --config &lt;your_conf_file_path&gt;&quot;</code>;</li>
<li>Then you will get one <code>stats.json</code> file in the root directory;</li>
<li>Use it on http://webpack.github.io/analyse/. Webpack will tell you everything about this bundling, especially the chunks and modules dependency relationships;</li>
</ul>
<p>This is the official analyse tool, you also have some <a href="http://webpack.github.io/analyse/">other options</a>. Personally, I prefer <a href="https://github.com/webpack-contrib/webpack-bundle-analyzer">webpack bundle analyzer</a>, which will give a clear and intuitional map like this:</p>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/luxliu/Picbed_picGo/master/webpack/webpack-bundle-analyzer.png" alt="" loading="lazy"></figure>
<p>Now, let's back to the previous example:</p>
<pre><code class="language-js">const getComponent = () =&gt; {
  return import('lodash').then(({ default: _ }) =&gt; {
    const element = document.createElement('div');
    element.innerHTML = _.join(['Lux', 'Liu'], '-');
    return element;
  });
};

document.addEventListener('click', () =&gt; {
  getComponent().then((element) =&gt; {
    document.body.appendChild(element);
  });
});
</code></pre>
<p>Normally, when we define a click event we will write like this instead of the top one in the <code>index.js</code> file:</p>
<pre><code class="language-js">document.addEventListener('click', () =&gt; {
   const element = document.createElement('div');
   element.innerHTML = _.join(['Lux', 'Liu'], '-');
   document.body.appendChild(element);
});
</code></pre>
<p>It's pretty simple and good enough, right? Is there any place to optimize?</p>
<p>Bundle this app and inspect <code>index.html</code> in browser, for chrome, open the dev tool. Press <kbd>ctrl</kbd>+<kbd>shift</kbd>+<kbd>P</kbd>, and input <strong>coverage</strong> then choose <strong>show coverage</strong>, you should get a new dev window open similar with this:</p>
<figure data-type="image" tabindex="2"><img src="https://raw.githubusercontent.com/luxliu/Picbed_PicGo/master/webpack/coverage.png" alt="" loading="lazy"></figure>
<p>This coverage window tells you how much the code is used on this page for all requested files right now. The red bar is unused part and blue bar is used part on this page. If we wanna improve performance, we should minimize the red part.</p>
<p>How to do this in our code?</p>
<p>The main idea is to use dynamic/async import to split unused logic:</p>
<ol>
<li>
<p>create a <code>click.js</code> file:</p>
<pre><code class="language-js">const handleClick = () =&gt; {
    const element = document.createElement('div');
    element.innerHTML = 'Lux Liu';
    document.body.appendChild(element);
}

export default handleClick;
</code></pre>
</li>
<li>
<p>Dynamically import and use it in <code>index.js</code> file:</p>
<pre><code class="language-js">document.addEventListener('click', () =&gt; {
   import('./click.js').then(({default: func})=&gt;{
       func();
   })
});
</code></pre>
</li>
</ol>
<p>Obviously, webpack will split the async import code in different file. This means we implement the lazy loading, and the coverage of <code>main.js</code> will increase as the logic code decreases. Finally, the performance will be improved. That's why I said webpack encourages developers to write more dynamic import code.</p>
<p>However, we still have a problem: let's say we use this approach to implement an app which has a sign in/sign up popup modal. With this approach, this modal module won't be requested on the landing page until the user clicks a button to tell modal to popup.</p>
<p>The question is: how would we handle the gap issue between click and modal module request finishes?</p>
<p>The ideal solution for this problem should be like this: when the landing page code files requests finish, and the network resource is released, could we let browser request the sign in/sign up modal code file quietly?</p>
<p><a href="https://webpack.js.org/guides/code-splitting/#prefetchingpreloading-modules">Prefetching/Preloading</a> can do this for us.</p>
<p>It's very straight forward: add a magic comment when you import the splitting module:</p>
<pre><code class="language-js">document.addEventListener('click', () =&gt; {
   import(/* webpackPrefetch: true */ './click.js').then(({default: func})=&gt;{
       func();
   })
});
</code></pre>
<blockquote>
<p>A preloaded chunk starts loading in parallel to the parent chunk. A prefetched chunk starts after the parent chunk finishes loading</p>
</blockquote>
<p>Personally I prefer prefetch than preload.</p>
<h4 id="4-code-coverage-caching">4. Code coverage &gt; caching</h4>
<p>Usually when we talk about the performance of a web app, we are not talking the caching but the first UX performance, which means we are talking the bundle size and files request order.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Use CircleCI to implement CI/CD and deploy to AWS S3]]></title>
        <id>https://luxliu.github.io/post/use-circleci-to-implement-cicd-of-front-end-code-and-deploy-to-aws-s3/</id>
        <link href="https://luxliu.github.io/post/use-circleci-to-implement-cicd-of-front-end-code-and-deploy-to-aws-s3/">
        </link>
        <updated>2020-04-07T21:31:44.000Z</updated>
        <content type="html"><![CDATA[<h3 id="some-important-concepts-before-we-start">Some important concepts before we start</h3>
<h4 id="1-cicd">1. CI/CD</h4>
<p>During the development of a project, developers will commit and push code to the main branch of a shared repository frequently. Of course, before commit/push, we usually need to run tests and check code style to insure the new code could integrate with existing code very well.</p>
<p>With this purpose, Continuous Integration (CI) and Continuous Deployment (CD) provide a sort of common software development practice. This is how them work:</p>
<ol>
<li>
<p>Developers check the code locally on their computers</p>
</li>
<li>
<p>When completed â€” they commit changes to the repository</p>
</li>
<li>
<p>Repository sends a request (webhook) to CI system (usually we can config which branch will execute which jobs pipeline)</p>
</li>
<li>
<p>CI server runs job (tests, coverage, lint and others)</p>
</li>
<li>
<p>CI server releases saved artifacts for testing</p>
</li>
<li>
<p>If the build or tests fail, the CI server alerts the team</p>
</li>
<li>
<p>The team fixes the issue</p>
</li>
<li>
<p>If the build and tests succeed, the CD server (if has) deploys current branch code to app server (in this case, we will show how to deploy to AWS s3 bucket)</p>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/luxliu/Picbed_picGo/master/cicd-flow.png" alt="" loading="lazy"></figure>
</li>
</ol>
<blockquote>
<p><em><strong>Bonus</strong></em></p>
<p>How to distinguish these concepts? DevOps, Agile development, CI and CD. This image can tell you all of them</p>
</blockquote>
<img src="https://raw.githubusercontent.com/luxliu/Picbed_picGo/master/concepts-compare.png"/>
<h4 id="2-create-a-react-project-with-cra">2. Create a React project with CRA</h4>
<p>We will create a React app with <a href="https://create-react-app.dev/">Create React App (CRA)</a> to connect with CircleCI server and deploy to AWS S3 bucket. <a href="https://create-react-app.dev/docs/getting-started/">This</a> official doc will help you to initialize a React app with it.</p>
<p>After you finish it, you should get a web app project with following output:</p>
<pre><code class="language-javascript">my-app
â”œâ”€â”€ README.md
â”œâ”€â”€ node_modules
â”œâ”€â”€ package.json
â”œâ”€â”€ .gitignore
â”œâ”€â”€ public
â”‚   â”œâ”€â”€ favicon.ico
â”‚   â”œâ”€â”€ index.html
â”‚   â”œâ”€â”€ logo192.png
â”‚   â”œâ”€â”€ logo512.png
â”‚   â”œâ”€â”€ manifest.json
â”‚   â””â”€â”€ robots.txt
â””â”€â”€ src
    â”œâ”€â”€ App.css
    â”œâ”€â”€ App.js
    â”œâ”€â”€ App.test.js
    â”œâ”€â”€ index.css
    â”œâ”€â”€ index.js
    â”œâ”€â”€ logo.svg
    â””â”€â”€ serviceWorker.js
</code></pre>
<p>In this project, we already have the <code>start</code>,  <code>test</code> and <code>build</code> features, and it already was initialized as a git project. Cool, all done.</p>
<h4 id="3-push-your-local-project-to-a-remote-repository">3. Push your local project to a remote repository</h4>
<p>CircleCI supports <a href="github.com"><strong>Github</strong> </a> or <a href="https://bitbucket.org/product/"><strong>Bitbucket</strong></a>, here we will use Github as remote repository.</p>
<ol>
<li>
<p>Create a new repo in Github for <code>my-app</code> code:</p>
<figure data-type="image" tabindex="2"><img src="https://raw.githubusercontent.com/luxliu/Picbed_picGo/master/circle-cicd/github-new-cicd-prject.JPG" alt="" loading="lazy"></figure>
</li>
<li>
<p>Use command line to redirect to the root of <code>my-app</code> and push code</p>
<pre><code>git remote add origin git@github.com:&lt;your-user-name&gt;/my-circleci-example.git
git push -u origin master
</code></pre>
<p>The code should be in your Github <code>my-circleci-example</code> repo right now.</p>
</li>
<li>
<p>Keep your machine login on Github right now.</p>
</li>
</ol>
<h3 id="4-connect-with-circleci">4. Connect with CircleCI</h3>
<ol>
<li>
<p>Just <a href="https://circleci.com/login">login to CircleCI</a>. When GitHub prompts you to authorize CircleCI, click the <strong>Authorize application</strong> button. And maybe you also need to choose which organization will be connected if you have multiple organizations within Github account.</p>
</li>
<li>
<p>You will be redirected to Projects page, you can set up and follow repos here.</p>
</li>
</ol>
<figure data-type="image" tabindex="3"><img src="https://raw.githubusercontent.com/luxliu/Picbed_picGo/master/circle-cicd/projects-page.JPG" alt="" loading="lazy"></figure>
<ol start="3">
<li>
<p>Click <kbd>Set Up Project</kbd> button and on next page, choose <code>Node</code> from the dropdown list. Right now you should see the default Node <code>config.yml</code> content:</p>
<pre><code class="language-javascript"> version: 2.1
 orbs:
   node: circleci/node@1.1.6
 jobs:
   build-and-test:
     executor:
       name: node/default
     steps:
       - checkout
       - node/with-cache:
           steps:
             - run: npm install
             - run: npm test
 workflows:
     build-and-test:
       jobs:
         - build-and-test
</code></pre>
</li>
</ol>
<blockquote>
<p><a href="https://circleci.com/docs/2.0/configuration-reference/#orbs-requires-version-21"><code>orbs</code></a> :  A reusable package of YAML configuration that condenses repeated pieces of config into a 	  single line of code. In this case, we will use pre-build <code>node</code> and <code>aws-s3</code> orbs. You also can create your own orbs for your organization.</p>
<p><a href="https://circleci.com/docs/2.0/configuration-reference/#jobs"><code>jobs</code></a>: a set of the job what you intend to do during this CI process. We only have <code>build-and-test</code> right now. Within we have <code>excutor</code> which is the environment where the steps of this job run.</p>
<p><a href="https://circleci.com/docs/2.0/configuration-reference/#workflows"><code>workflows</code></a>: tell CircleCI how to run the jobs. You can add a bunch of configs for the schedule here.</p>
<p><em><strong>You can find all configuration docs of this <code>config.yml</code>  <a href="https://circleci.com/docs/2.0/configuration-reference/">here</a>.</strong></em></p>
</blockquote>
<p>We can click the rightmost button <kbd>Add Config</kbd> to use this default config and start CI process. This is 	enough for now,  click it!</p>
<p>You should find you are redirected to the pipeline page and one pipeline is running.</p>
<figure data-type="image" tabindex="4"><img src="https://raw.githubusercontent.com/luxliu/Picbed_picGo/master/circle-cicd/pipeline.png" alt="" loading="lazy"></figure>
<p>Seconds ago, CircleCI created a new branch <strong>circleci-project-setup</strong> and a new commit <code>Add .circleci/config.yml</code> . This initial pipeline should take just seconds and succeed.</p>
<ol start="4">
<li>
<p>Go back to the example repo on Github, you will find Github gives to you a notification of new branch and new commit. Right now you need to create a pull request and merge this branch to <code>master</code> branch. You can do it on Github page simply for now.</p>
</li>
<li>
<p>Once you finish the merge, the CircleCI will run the pipeline again, this time it's for <code>master</code> branch, and of course the commit is the new PR merge commit.</p>
<img src="https://raw.githubusercontent.com/luxliu/Picbed_picGo/master/circle-cicd/master-pipeline.png"/>
</li>
</ol>
<h4 id="5-write-our-own-config-file-and-deploy-production-version-to-aws-s3-bucket">5. Write our own config file and deploy production version to AWS S3 bucket</h4>
<p>Let's start the CD part!</p>
<p>First of all, you need create a new S3 bucket on AWS. Let's say you already had the AWS account and you are using the <strong>non-root</strong> IAM account right now.</p>
<ol>
<li>
<p>Create a new bucket named <strong>my-circleci-example</strong> and <strong>untick</strong> the <strong>Block all public access</strong>, which make your bucket can be accessed from internet.</p>
</li>
<li>
<p>Go to the new bucket &gt; click <strong>Permissions</strong> tab &gt; click <strong>Bucket Policy</strong> button &gt; In the editor change the bucket policy with the following policy and save.</p>
<pre><code class="language-json">{
    &quot;Version&quot;: &quot;2012-10-17&quot;,
    &quot;Statement&quot;: [
        {
            &quot;Sid&quot;: &quot;PublicReadGetObject&quot;,
            &quot;Effect&quot;: &quot;Allow&quot;,
            &quot;Principal&quot;: &quot;*&quot;,
            &quot;Action&quot;: &quot;s3:GetObject&quot;,
            &quot;Resource&quot;: &quot;arn:aws:s3:::my-circleci-example/*&quot;
        }
    ]
}
</code></pre>
</li>
<li>
<p>Back to <strong>Properties</strong> tab and click <strong>Static website hosting</strong> block, config it like this and save:</p>
<figure data-type="image" tabindex="5"><img src="https://raw.githubusercontent.com/luxliu/Picbed_picGo/master/circle-cicd/bucket-hosting.png" alt="" loading="lazy"></figure>
<p>If you click the <strong>Endpoint</strong>, of course you will get a 404 error page. Right now we'll upload the app code via CircleCI.</p>
</li>
<li>
<p>Now we need get the AWS access for CircleCI. Search IAM in the AWS services, then go to page of the user who created the new bucket. Then go to <strong>Security credentials</strong> tab, and click <strong>Create access key</strong> button to create a pair of access key ID and secret key.</p>
<figure data-type="image" tabindex="6"><img src="https://raw.githubusercontent.com/luxliu/Picbed_picGo/master/circle-cicd/get-aws-access-key.png" alt="" loading="lazy"></figure>
<p>Don't forget to get the bucket region as well.</p>
</li>
<li>
<p>Where should we put these credentials? Of course <strong>NOT</strong> in the code. We can put them in the project environment variables on CircleCI !</p>
<p>Back to the pipeline page of CircleCI, then click the top-right button <kbd>Project Settings</kbd> , then switch to <strong>Environment Variables</strong> link, you can add all three variables here.</p>
<figure data-type="image" tabindex="7"><img src="https://raw.githubusercontent.com/luxliu/Picbed_picGo/master/circle-cicd/environment-variables-circleci.png" alt="" loading="lazy"></figure>
<p><em><strong>NOTE:</strong></em> the variable naming should follow the picture as they are default values of <code>aws-s3</code> orb. you can customized the variable naming and override them in  config YAML file. This is the <a href="https://circleci.com/orbs/registry/orb/circleci/aws-s3">official doc</a> of <code>aws-s3</code> orb.</p>
</li>
<li>
<p>Back to local <code>my-app</code> code first, and on <code>master</code> branch run<code>git pull</code> to get the new code. Right now you should have a new <code>.circle</code> folder and a file <code>config.yml</code> within locally.</p>
</li>
<li>
<p>Create a new branch <code>add-deploy-config</code>, and modify this config YAML file like this:</p>
<pre><code class="language-javascript">version: 2.1
orbs:
  node: circleci/node@1.1.6
  aws-s3: circleci/aws-s3@1.0.15
jobs:
  test-and-build:
    executor:
      name: node/default
    steps:
      - checkout
      - node/with-cache:
          steps:
            - run: npm install
            - run: npm test
      - run: npm run build
      - persist_to_workspace:
          root: ~/
          paths:
            - project/build
  deploy-to-s3:
    machine:
      image: circleci/classic:latest
    steps:
      - checkout
      - attach_workspace:
          at: ~/
      - aws-s3/sync:
          arguments: |
            --acl public-read \
            --cache-control &quot;max-age=86400&quot;
          from: build
          to: 's3://my-circleci-example'
          overwrite: true # default is false
workflows:
  build-and-deploy:
    jobs:
      - test-and-build
      - deploy-to-s3:
          requires:
            - test-and-build
          filters:
            branches:
              only: master
</code></pre>
<p>Let's have a dive into this new configuration:</p>
<blockquote>
<p>We have a new job: <code>deploy-to-s3</code> . This job only runs when <code>test-and-build</code> finishes and the current branch is <code>master</code> branch.</p>
<p>Within this <code>deploy-to-s3</code>, we use <code>aws-s3</code> orb to do the code sync job: from <em><strong>build</strong></em> folder to <em><strong>s3://my-circleci-example</strong></em> bucket, and delete content in bucket first (with <em><strong>overwrite</strong></em> <code>true</code>.</p>
<p><em><strong>NOTE</strong></em>: if you want to share some content between different workflow jobs, which are <code>test-and-build</code> and <code>deploy-to-s3</code> here, you have to share the <a href="https://circleci.com/docs/2.0/concepts/#caches-workspaces-and-artifacts"><strong>workspace</strong></a> between them. We use <code>persist_to_workspace</code> to persist the <code>build</code> result, and use <code>attach_workspace</code> in ``deploy-to-s3` to get it.</p>
</blockquote>
</li>
<li>
<p>Right now you can stage, commit and push the new branch <code>add-deploy-config</code> to Github. CircleCI will run the pipeline for this branch, of course it will ignore the <code>deploy-to-s3</code> job.</p>
</li>
<li>
<p>On Github page, you need do the same thing: create a pull request then merge it! Look at the CircleCI pipeline page, you will have the successful <code>test-and-build</code> then <code>deploy-to-s3</code> .</p>
</li>
</ol>
<p>Finally, you can go to the endpoint to have a look at what you just deployed.</p>
<p>Have fun!ðŸ˜€</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[What skills should you upgrade when COVID-19 spreads]]></title>
        <id>https://luxliu.github.io/post/what-skills-should-you-upgrade-when-covid-19-spreading/</id>
        <link href="https://luxliu.github.io/post/what-skills-should-you-upgrade-when-covid-19-spreading/">
        </link>
        <updated>2020-03-28T18:44:43.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>This is a special period. Everyone is facing economic recession, salary deduction, even massive unemployment. As an IT people, we have to think about where the future is, and what we should do to prepare for it.</p>
</blockquote>
<h3 id="industry-structure-is-changing">Industry structure is changing</h3>
<p>A lot of industries are changing rapidly because of the pandemic. Especially some population-intensive businesses like some non-essential manufacturing, cinema, bar, and casino. People stay at home and what they need is only the necessities of life. So you can have a think about your industry you are serving and its value chain. How is it  impacted by the virus? Is this impact short-term or long-term? I'm not encouraging you leave your company right now, but just think about it right now.</p>
<p>Currently, everybody knows only the essential industries are stable. Food, water, power and healthcare, they are necessary for our daily life. However they won't provide many opportunities to us IT practitioners. We have to focus something else. Everything is changing to remote, remote meeting, remote teaching, even remote gym. Meanwhile the online entertainment is booming. The VR and AI technology maybe attract capital again.</p>
<p>If you are interested in these industries, maybe you can start learn from now.</p>
<h3 id="scale-your-skills-horizontally">Scale your skills horizontally</h3>
<p>If you live in a small country, like me, I suggest you should scale your IT skills horizontally.</p>
<p>Small country usually has more small-medium enterprises(SME), and SME needs employees can do everything. The most important thing to SME is surviving, so do we.</p>
<p>If you are a front-end developer, then study some back-end skills to become a full-stack developer. If you are an IT supporter, maybe you can consider to learn some coding skills.</p>
<blockquote>
<p>The battle is not only about the pandemic, but also the economic recovering. We will win this battle, the question is when.</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Use webpack to bundle styling files]]></title>
        <id>https://luxliu.github.io/post/use-webpack-to-bundle-styling-files/</id>
        <link href="https://luxliu.github.io/post/use-webpack-to-bundle-styling-files/">
        </link>
        <updated>2020-03-17T02:01:35.000Z</updated>
        <content type="html"><![CDATA[<p>As a popular bundling tool, webpack has a lot of configurations to learn. It's impossible to know everything about the loaders/plugins and their configurations, but we need to know some general configs for normal files, like  <code>.css</code> or <code>.scss</code>.</p>
<h4 id="1-clone-repo-and-init">1. Clone repo and init</h4>
<p>First, you need clone the <a href="https://github.com/luxliu/webpack-bundle-style-files">demo project</a> for this article from git, and run <code>npm i</code> in the root directory. This will install necessary packages: <code>webpack</code>, <code>webpack-cli</code>, <code>file-loader</code> and <code>url-loader</code>.</p>
<p>Let's have a look this project from top to bottom:</p>
<p><code>dist</code> folder: this is the bundle output place, right now there is only one <code>index.html</code> inside.</p>
<p>Dive in this <code>index.html</code>, you can see a <code>&lt;div&gt;</code> with <strong>root</strong> id and a <code>./bundle.js</code> imported.</p>
<p><code>src/index.js</code>: the logic inside is pretty straight forward. Just import an image named <strong>avatar.jpg</strong> and append it into the <code>&lt;div&gt;</code> with <strong>root</strong> id in <code>dist/index.html</code>.</p>
<p><code>webpack.config.js</code>: this file is the configuration file for webpack and uses <strong>commonJS</strong> module management convention to export configuration object. The naming <strong>webpack.config.js</strong> is the default value. You can change it to any other names, but then when you run <code>weboack</code> you need to add a suffix: <code>--config &lt;your-config-file-name&gt;</code>.</p>
<p>In this project, I will use an image to display how to add loaders for <code>.css</code> and <code>.sass</code>. That means I need use a appropriate loader to handle <code>.jpg</code> file. I use <code>url-loader</code> here.</p>
<blockquote>
<p><strong><a href="https://webpack.js.org/loaders/url-loader/">url-loader</a></strong>: this loader will encode image file content to base64 url and insert it to the <code>src</code> of <code>&lt;img&gt;</code>. However, this will cause a unfriendly UX when the image is too big. I used <strong>limit</strong> to handle this case: if the size is bigger than 10240 bytes, <strong>url-loader</strong> will handle the image like <strong>file-loader</strong>, which moves the image file to output folder directly.</p>
</blockquote>
<p>Right now you can in the cli to run <code>npm run bundle</code>, then image and <code>bundle.js</code> will appear in the <kbd>dist</kbd>folder. You can open <code>index.html</code> in browser, and you should see the avatar image there.</p>
<h4 id="2-bundle-css-and-scss-file">2. Bundle <code>.css</code> and <code>.scss</code> file</h4>
<p>First, create <code>index.css</code> file under <kbd>src</kbd> folder, and write some styling code:</p>
<pre><code class="language-css">.avatar {
  width: 150px;
  height: 150px;
}
</code></pre>
<p>Now, we have the <code>.css</code> file, we need to use it in <code>index.js</code>. Import the css file and add a class name to the image DOM:</p>
<pre><code class="language-js">...
import './index.css';
...
img.classList.add('avatar');
...
</code></pre>
<p>The logic part is already finished. We need tell webpack how to bundle <code>.css</code> file. Install two loaders: <code>npm i style-loader css-loader -D</code> and add a new rule in <code>weboack.config.js</code>:</p>
<pre><code class="language-javascript">{
   test: /\.css$/,
   use: ['style-loader', 'css-loader'],
}
</code></pre>
<p>The rule is pretty simple: if the file has <code>.css</code> extension, webpack will use <code>css-loader</code> to handle the importing relationship between all <code>.css</code> files <strong>first</strong>, then use <code>style-loader</code> to insert these styling code to <code>&lt;style&gt;</code> tag of <code>index.html</code>.</p>
<blockquote>
<p>When use multiple loaders in one rule, webpack will use them from bottom to top, from right to left.</p>
</blockquote>
<p>You can run <code>npm run bundle</code> and check <code>index.html</code> in browser right now. The image should be smaller and inspect the html in dev tool of browser, the css styling code should be placed in a <code>&lt;style&gt;</code> in <code>&lt;head&gt;</code>.</p>
<p>Next, we can just change a little bit and bundle the <code>.scss</code> file.</p>
<p>Modify the <code>index.css</code> to <code>index.scss</code>, then replace the code with following content:</p>
<pre><code class="language-scss">body {
  .avatar {
    width: 150px;
    height: 150px;
  }
}
</code></pre>
<p>Don't forget to change importing <code>index.css</code> to <code>index.scss</code> in <code>index.js</code> top.</p>
<p>Then install <code>sass-laoder</code> : <code>npm i sass-loader node-sass -D</code>. Modify the rule in <code>webpack.config.js</code> like this:</p>
<pre><code class="language-javascript"> {
   test: /\.scss$/,
   use: ['style-loader', 'css-loader', 'sass-loader'],
 }
</code></pre>
<p>You can run bundle command and test <code>index.html</code> in your browser.</p>
<h4 id="3-postcss-and-autoprefixer">3. PostCSS and Autoprefixer</h4>
<p>Sometimes we need add the prefix for different browser engines, like <code>-webkit-</code>, <code>-ms-</code> and <code>-o-</code>, for some css3 properties. We can use <a href="https://webpack.js.org/loaders/postcss-loader/">postcss-loader</a> and its plugin <a href="https://github.com/postcss/autoprefixer">Autoprefixer</a> to ignore this kind of inconvenience.</p>
<blockquote>
<p><a href="https://github.com/postcss/postcss">PostCSS</a> plugin to parse CSS and add vendor prefixes to CSS rules using values from <a href="https://caniuse.com/">Can I Use</a>. It is <a href="https://developers.google.com/web/tools/setup/setup-buildtools#dont_trip_up_with_vendor_prefixes">recommended</a> by Google and used in Twitter and Alibaba.</p>
</blockquote>
<p>First, install <code>npm i postcss-loader autoprefixer -D</code>. Then add <code>postcss-loader</code> in <code>.scss</code> rule of <code>webpack.config.js</code>.</p>
<pre><code class="language-javascript">{
  test: /\.scss$/,
  use: ['style-loader', 'css-loader', 'postcss-loader', 'sass-loader'],
}
</code></pre>
<p>Add a config file <code>postcss.config.js</code> in root directory, and write following code:</p>
<pre><code class="language-js">module.exports = {
  plugins: [
  	require('autoprefixer')
  ]
}
</code></pre>
<p>Add a css3 property for <code>.avatar</code> in <code>index.scss</code>:</p>
<pre><code class="language-css">transform: rotate(20deg);
</code></pre>
<p>Don't forget tell <strong>Autoprefixer</strong> what the target browsers of this project, add this in your <code>package.json</code> file:</p>
<pre><code class="language-json">&quot;browserslist&quot;: [
   &quot;last 2 versions&quot;
]
</code></pre>
<p>At last, run <code>npm run bundle</code> and inspect in browser, you will find for <code>.avatar</code> image, the styling will be like this:</p>
<pre><code class="language-css">width: 150px;
height: 150px;
-webkit-transform: rotate(20deg);
transform: rotate(20deg);
</code></pre>
<h4 id="4-css-module">4. CSS module</h4>
<p>Let's create a new file <code>createAvatar.js</code> in <kbd>src</kbd> folder, then copy exactly same code from <code>index.js</code>. Paste it into a function ``createAvatar` and export this function:</p>
<pre><code class="language-js">import avatar from './avatar.jpg';

export default () =&gt; {
  var img = new Image();
  img.src = avatar;
  img.classList.add('avatar');

  var root = document.getElementById('root');
  root.append(img);
};
</code></pre>
<p>Then we import and call this function in <code>index.js</code>:</p>
<pre><code class="language-js">import avatar from './avatar.jpg';
import './index.scss';
import createAvatar from './createAvatar';

createAvatar();

var img = new Image();
img.src = avatar;
img.classList.add('avatar');

var root = document.getElementById('root');
root.append(img);
</code></pre>
<p>Let's bundle and have a look at the <code>index.html</code> in browser.</p>
<p>Of course you will get 2 exactly same images.</p>
<p>Find any issue with this? You imported <code>createAvatar</code> in <code>index.js</code> and only import <code>index.scss</code> once in <code>index.js</code> but the styling will apply to global! This is not good as when you modify the style of one module, may modify other modules as well.</p>
<p>That's why we need css module.</p>
<p>With webpack, it's really easy to implement css module.</p>
<p>First, add an option for <code>css-loader</code>:</p>
<pre><code class="language-js">{
  test: /\.scss$/,
  use: [
     'style-loader',
     {
       loader: 'css-loader',
       options: {
           modules: true,
       },
      },
      'postcss-loader',
      'sass-loader',
  ],
}
</code></pre>
<p>Then, modify the importing and logic code in <code>index.js</code> like this:</p>
<pre><code class="language-js">...
import style from './index.scss';
...
img.classList.add(style.avatar);
</code></pre>
<p>Re-bundle and you will see the first image has no any style but the second one gets styles as we expected.</p>
]]></content>
    </entry>
</feed>